# Cluster Access: Operations Manual

This document explains how long-term cluster access works in the IDP demo.

## Problem

- **Short-term credentials:** SKE kubeconfig has ~8h validity period
- **Production readiness:** A platform that becomes undeployable after 8h is not production-ready
- **Automation:** Terraform must reliably manage K8s resources over weeks/months

## Solution: Three-Layer Architecture with ServiceAccount-Based Access

See **ADR-002** (Bootstrap Platform Components) for architecture details.

---

## Workflow: Development & Testing

### Phase 1: Validate All Layers (optional)

```bash
make validate
```

Ensures all three layers are syntactically correct.

### Phase 2: Deploy Provision Layer

```bash
make provision
```

**What happens:**
1. SKE cluster is created (~9-10 min)
2. Harbor Registry is configured (~1-2 min)
3. Terraform exports:
   - `kube_host`: K8s API URL
   - `cluster_ca_certificate`: CA certificate
   - `bootstrap_client_certificate`: Client cert (expires ~8h)
   - `bootstrap_client_key`: Client key

### Phase 3: Deploy Configure Layer

```bash
make configure
```

**What the Makefile does:**
1. âœ… Checks that Provision is deployed
2. âœ… Reads Provision's `terraform.tfstate` and extracts outputs
3. âœ… Writes outputs to `bootstrap/platform/configure/terraform.auto.tfvars.json`
4. âœ… Deploys Configure layer with credential injection

**What Configure deploys:**
1. Kubernetes provider (certificate-based auth from Provision)
2. `platform-admin` namespace
3. `platform-terraform` ServiceAccount + ClusterRole (8 permission rules)
4. Kubernetes Secret containing long-lived token
5. Data source extracts token from secret
6. Exports: `app_env_kube_host`, `app_env_kube_ca_certificate`, `app_env_kube_token`

### Phase 4: Deploy App-Env Layer

```bash
make app-env
```

**What the Makefile does:**
1. âœ… Checks that Configure is deployed
2. âœ… Reads Configure's `terraform.tfstate` and extracts outputs
3. âœ… Writes outputs to `app-env/terraform.auto.tfvars.json`
4. âœ… Deploys App-Env with token-based authentication

**What App-Env deploys:**
1. Kubernetes provider (token-based auth from Configure)
2. `demo-app` namespace
3. ResourceQuota (4 CPU, 8Gi memory requests)
4. LimitRange (100m-2 CPU per container)
5. NetworkPolicies (deny-all ingress/egress)

**Important:**
- âœ… Each layer is completely independent
- âœ… Credentials flow through explicit state injection (Python scripts)
- âœ… No tight coupling, no terraform_remote_state
- âœ… Provision layer expires but Configure token is persistent

### Phase 5: Test Cluster Connectivity

```bash
# Automated tests
make test-connection

# Or manual testing
make kubeconfig
export KUBECONFIG=/tmp/kubeconfig-token
kubectl get ns demo-app
```

---

## Testing with kubectl

### Generate Long-Lived kubeconfig

The `make kubeconfig` target generates a kubeconfig using the persistent platform-terraform token:

```bash
make kubeconfig
```

This shows:

```
ðŸ“‹ To use kubectl with proper credentials, run:

  export KUBECONFIG=/tmp/kubeconfig-token

Or in one line:

  eval "$(make kubeconfig)" && echo 'export KUBECONFIG=/tmp/kubeconfig-token'

Then test with:
  kubectl get ns
  kubectl get ns demo-app
```

### Manual Token Extraction

If you need to extract the token directly:

```bash
# Extract from Configure layer state
terraform -chdir=terraform/bootstrap/platform/configure output -raw app_env_kube_token

# Store for future deployments (securely!)
TOKEN=$(terraform -chdir=terraform/bootstrap/platform/configure output -raw app_env_kube_token)

# Use with kubectl
export KUBECONFIG=/tmp/my-kubeconfig
kubectl config set-cluster stackit-cluster --server=https://...
kubectl config set clusters.stackit-cluster.certificate-authority-data "$(base64 < ca.crt)"
kubectl config set-credentials platform-terraform --token="$TOKEN"
kubectl config set-context stackit-cluster --cluster=stackit-cluster --user=platform-terraform
kubectl config use-context stackit-cluster
```

---

## Credential Lifecycle

| Component | Lifespan | Management | Usage |
|---|---|---|---|
| Provision kubeconfig (Client-Cert) | ~8h | Generated by SKE provider | Certificate-based auth for Configure layer |
| Configure layer state | Indefinite | Filesystem | Source of truth for credentials |
| platform-terraform token | Indefinite | K8s Secret (in platform-admin namespace) | Token-based auth for App-Env layer |
| App-Env state | Indefinite | Filesystem | Proof of deployment |

**Flow:**

```
Provision Layer:
  SKE kubeconfig (8h) 
    â†“
  [inject-provision-to-configure.py]
    â†“
  Configure/terraform.auto.tfvars.json
    â†“

Configure Layer:
  Certificate-based auth â†’ Create platform-terraform ServiceAccount + Secret
  Long-lived token in Secret
    â†“
  [inject-configure-to-appenv.py]
    â†“
  App-Env/terraform.auto.tfvars.json
    â†“

App-Env Layer:
  Token-based auth â†’ Deploy namespace + policies
  Persistent credentials stored in state file
```

---

## Admin Access (kubectl)

For manual admin access to the cluster:

### Option A: Using the long-lived token (recommended)

```bash
make kubeconfig
export KUBECONFIG=/tmp/kubeconfig-token
kubectl get nodes
```

### Option B: Using fresh credentials from Provision layer

```bash
# Refresh Provision outputs (gets fresh SKE kubeconfig)
cd demo/terraform/bootstrap/platform/provision
terraform refresh

# Extract fresh credentials
cd ../../../
export KUBECONFIG=demo/terraform/bootstrap/platform/provision/kubeconfig
kubectl get nodes
```

**Note:** This kubeconfig will expire after ~8h. Use Option A for longer sessions.

---

## Troubleshooting

### "Unauthorized" when running make configure

**Cause:** Provision credentials not injected properly

**Solution:**

```bash
# 1. Check if terraform.auto.tfvars.json was created
cat terraform/bootstrap/platform/configure/terraform.auto.tfvars.json

# 2. Re-run injection
python3 scripts/inject-provision-to-configure.py

# 3. Check Provision state exists and is valid
terraform -chdir=terraform/bootstrap/platform/provision state list

# 4. Retry configure
make configure
```

### "Unauthorized" when running make app-env

**Cause:** Configure credentials not injected properly

**Solution:**

```bash
# 1. Check if terraform.auto.tfvars.json was created
cat terraform/app-env/terraform.auto.tfvars.json

# 2. Re-run injection
python3 scripts/inject-configure-to-appenv.py

# 3. Check Configure state exists and contains outputs
terraform -chdir=terraform/bootstrap/platform/configure output

# 4. Retry app-env
make app-env
```

### kubectl commands fail with permission errors

**Cause:** platform-terraform SA has limited permissions by design

**Note:** This is expected! platform-terraform can only:
- Read/list namespaces
- Read/list ResourceQuotas, LimitRanges, NetworkPolicies
- Read/list RBAC resources
- NOT create pods, deployments, or modify workloads

This is correct isolation for the automation layer.

### make kubeconfig fails

**Cause:** Configure layer not deployed

**Solution:**

```bash
# Deploy Configure first
make provision
make configure

# Then generate kubeconfig
make kubeconfig
```

### Token appears in logs/terminal

**Security note:** Tokens may appear in:
- Terraform logs (especially in -verbose mode)
- kubectl output when describing secrets
- Your shell history

**Best practices:**
1. Don't commit terraform.auto.tfvars.json to Git
2. Rotate tokens periodically
3. Use Secrets Manager for production
4. Clear shell history: `history -c`
5. Set `HISTFILE=/dev/null` for sensitive sessions

---

## Best Practices

1. **Never commit kubeconfig or terraform.auto.tfvars.json to Git**
   - These contain live credentials
   - They expire or become invalid
   - Add to .gitignore

2. **Store long-lived tokens securely**
   - Vault, AWS Secrets Manager, or similar
   - Encrypted git if necessary (e.g., git-crypt)
   - Never in plain text

3. **Test regularly**
   - Run `make test-connection` weekly
   - Monitor token expiration
   - Plan token rotation strategy

4. **Layer independence**
   - Each layer can be re-deployed independently
   - Provision layer expiration doesn't affect App-Env
   - Credentials flow through explicit injection only

5. **Audit and monitoring**
   - Log all terraform applies
   - Monitor ServiceAccount token usage
   - Alert on authentication failures

6. **Token rotation strategy**
   - Current: Manual via Configure layer re-deploy
   - Future: Kubernetes CronJob for automatic rotation
   - Consider: Secrets Manager integration

---

## Future Improvements

- [ ] Automatic token rotation (Kubernetes CronJob)
- [ ] Secrets Manager integration (Vault, AWS Secrets)
- [ ] OIDC-federated ServiceAccounts (if STACKIT supports)
- [ ] Per-application ServiceAccounts (instead of shared platform-terraform)
- [ ] Remote Backend support (S3, Terraform Cloud)
- [ ] Automated kubeconfig refresh in CI/CD
- [ ] Token expiration monitoring and alerts
- [ ] Multi-cluster support with credential scoping
