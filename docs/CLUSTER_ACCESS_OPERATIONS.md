# Cluster Access: Operations Manual

This document explains how long-term cluster access works in the STACKIT IDP platform.

## Problem

- **Short-term credentials:** SKE kubeconfig has ~8h validity period
- **Production readiness:** A platform that becomes undeployable after 8h is not production-ready
- **Automation:** Terraform must reliably manage K8s resources over weeks/months

## Solution: ServiceAccount-Based Access

The platform uses Kubernetes ServiceAccounts for long-lived automation credentials. This ensures Terraform can manage cluster resources beyond the kubeconfig expiry window.

---

## Deployment Workflow

### Step 1: Deploy Platform Infrastructure

```bash
cd platform

# Set environment variables
export STACKIT_PROJECT_ID="your-project-id"
export STACKIT_SERVICE_ACCOUNT_KEY_PATH="~/.stackit/sa-key.json"
export HARBOR_USERNAME="admin"
export HARBOR_CLI_SECRET="your-harbor-secret"

# Deploy all platform components
terragrunt run-all plan
terragrunt run-all apply
```

**What happens:**
1. SKE cluster is created (~10 min)
2. Harbor registry is provisioned
3. meshStack integration is configured
4. ArgoCD is installed

### Step 2: Provision Application Namespace

```bash
cd platform/namespaces/team-a-dev
terragrunt apply
```

**What gets created:**
1. Kubernetes namespace with meshStack labels
2. Resource quotas and network policies
3. Harbor registry pull secret
4. ArgoCD Application CR for GitOps

### Step 3: Setup Application Repository

```bash
# Copy blueprint
cp -r app-repo-blueprint team-a-app
cd team-a-app

# Configure GitHub secrets (in GitHub UI):
# - HARBOR_USERNAME
# - HARBOR_PASSWORD
# - HARBOR_PROJECT

# Push to GitHub
git init
git remote add origin https://github.com/YOUR_ORG/team-a-app
git add .
git commit -m "Initial commit"
git push -u origin main
```

**GitOps automation:**
- GitHub Actions builds and pushes image
- CI updates Kustomize manifest with new image tag
- ArgoCD detects Git change and syncs to cluster

---

## Technical Details

### Terragrunt Dependency Management

```hcl
# platform/04-argocd/terragrunt.hcl
dependency "ske" {
  config_path = "../01-ske"
}

inputs = {
  kubeconfig_path = dependency.ske.outputs.kubeconfig_path
}
```

**How it works:**
- Terragrunt automatically manages execution order
- Outputs from dependencies are available as inputs
- S3 remote state configured in root `terragrunt.hcl`
- No manual state file manipulation needed

### Credential Lifecycle

| Component | Lifetime | Management | Usage |
|---|---|---|---|
| SKE kubeconfig (Client Cert) | ~8h | Generated by SKE provider | Local kubectl access |
| ArgoCD ServiceAccount | Indefinite | Created by ArgoCD module | GitOps automation |
| Harbor Robot Account | Indefinite | Created by Harbor module | Image push/pull |

**Flow:**

```
Platform Deployment:
  kubeconfig (8h) → [Install ArgoCD] → ServiceAccount created

Application Deployment:
  ArgoCD ServiceAccount → [Watch Git] → Sync to cluster
  Harbor Robot Account → [Pull images] → Deploy pods
```

---

## Admin Access (kubectl)

For manual cluster access:

```bash
# Get fresh kubeconfig from platform
cd platform/01-ske
terragrunt output kubeconfig_path

# Use kubeconfig
export KUBECONFIG=$(terragrunt output -raw kubeconfig_path)
kubectl get nodes
```

---

## Troubleshooting

### ArgoCD Application Not Syncing

**Check Application status:**
```bash
kubectl get applications -n argocd
kubectl describe application team-a-dev -n argocd
```

**Manual sync:**
```bash
argocd app sync team-a-dev
```

### Harbor Pull Failures

**Check pull secret:**
```bash
kubectl get secret harbor-pull-secret -n team-a-dev -o yaml
kubectl describe pod POD_NAME -n team-a-dev
```

### Kubeconfig Expired

**For admin access:**
```bash
cd platform/01-ske
terragrunt refresh
```

**For automation:** No issue - ArgoCD uses ServiceAccount credentials that don't expire.

### Terragrunt Dependency Issues

**Clear cache:**
```bash
find . -name ".terragrunt-cache" -type d -exec rm -rf {} +
terragrunt run-all init
```

**Check dependency graph:**
```bash
terragrunt graph-dependencies
```

---

## Best Practices

1. **Never commit kubeconfig** → expires after 8h, security risk
2. **Store Harbor credentials securely** → use GitHub Secrets for CI
3. **Test regularly** → `terragrunt run-all plan` weekly
4. **Backup state** → S3 bucket is critical
5. **Use GitOps** → let ArgoCD handle deployments
6. **Monitor ArgoCD** → watch for sync failures

---

## Building Blocks / meshStack Integration

The platform is **ready for meshStack Building Blocks**:

```hcl
# meshStack can wrap platform modules as Building Blocks
module "namespace" {
  source = "git::https://.../building-blocks/namespace-with-argocd"
  
  namespace_name        = var.meshstack_workspace_id
  github_repo_url       = var.team_git_repo
  harbor_robot_username = var.harbor_robot_username
  harbor_robot_token    = var.harbor_robot_token
}
```

**Integration points:**
- Building blocks are self-contained Terraform modules
- meshStack provides tenant/project metadata as variables
- Modules use Terragrunt dependencies for platform resources

---

## Future Enhancements

- [ ] ServiceAccount token rotation automation
- [ ] Vault integration for secrets
- [ ] OIDC-federated ServiceAccounts
- [ ] Multi-tenant RBAC (namespace-scoped ServiceAccounts)
- [ ] Prometheus/Grafana monitoring
- [ ] Ingress controller for external access
